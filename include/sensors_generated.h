// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SENSORS_SENSORLOG_H_
#define FLATBUFFERS_GENERATED_SENSORS_SENSORLOG_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace SensorLog {

struct BME688Data;
struct BME688DataBuilder;

struct ENS160Data;
struct ENS160DataBuilder;

struct LSM6D032Data;
struct LSM6D032DataBuilder;

struct MPLAltimeterData;
struct MPLAltimeterDataBuilder;

struct BNO055Data;
struct BNO055DataBuilder;

struct SensorMessage;
struct SensorMessageBuilder;

struct SensorBatch;
struct SensorBatchBuilder;

enum SensorType : int8_t {
  SensorType_BME688 = 0,
  SensorType_ENS160 = 1,
  SensorType_LSM6D032 = 2,
  SensorType_MPLAltimeter = 3,
  SensorType_BNO055 = 4,
  SensorType_MIN = SensorType_BME688,
  SensorType_MAX = SensorType_BNO055
};

inline const SensorType (&EnumValuesSensorType())[5] {
  static const SensorType values[] = {
    SensorType_BME688,
    SensorType_ENS160,
    SensorType_LSM6D032,
    SensorType_MPLAltimeter,
    SensorType_BNO055
  };
  return values;
}

inline const char * const *EnumNamesSensorType() {
  static const char * const names[6] = {
    "BME688",
    "ENS160",
    "LSM6D032",
    "MPLAltimeter",
    "BNO055",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorType(SensorType e) {
  if (::flatbuffers::IsOutRange(e, SensorType_BME688, SensorType_BNO055)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorType()[index];
}

enum SensorDataUnion : uint8_t {
  SensorDataUnion_NONE = 0,
  SensorDataUnion_BME688Data = 1,
  SensorDataUnion_ENS160Data = 2,
  SensorDataUnion_LSM6D032Data = 3,
  SensorDataUnion_MPLAltimeterData = 4,
  SensorDataUnion_BNO055Data = 5,
  SensorDataUnion_MIN = SensorDataUnion_NONE,
  SensorDataUnion_MAX = SensorDataUnion_BNO055Data
};

inline const SensorDataUnion (&EnumValuesSensorDataUnion())[6] {
  static const SensorDataUnion values[] = {
    SensorDataUnion_NONE,
    SensorDataUnion_BME688Data,
    SensorDataUnion_ENS160Data,
    SensorDataUnion_LSM6D032Data,
    SensorDataUnion_MPLAltimeterData,
    SensorDataUnion_BNO055Data
  };
  return values;
}

inline const char * const *EnumNamesSensorDataUnion() {
  static const char * const names[7] = {
    "NONE",
    "BME688Data",
    "ENS160Data",
    "LSM6D032Data",
    "MPLAltimeterData",
    "BNO055Data",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorDataUnion(SensorDataUnion e) {
  if (::flatbuffers::IsOutRange(e, SensorDataUnion_NONE, SensorDataUnion_BNO055Data)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorDataUnion()[index];
}

template<typename T> struct SensorDataUnionTraits {
  static const SensorDataUnion enum_value = SensorDataUnion_NONE;
};

template<> struct SensorDataUnionTraits<SensorLog::BME688Data> {
  static const SensorDataUnion enum_value = SensorDataUnion_BME688Data;
};

template<> struct SensorDataUnionTraits<SensorLog::ENS160Data> {
  static const SensorDataUnion enum_value = SensorDataUnion_ENS160Data;
};

template<> struct SensorDataUnionTraits<SensorLog::LSM6D032Data> {
  static const SensorDataUnion enum_value = SensorDataUnion_LSM6D032Data;
};

template<> struct SensorDataUnionTraits<SensorLog::MPLAltimeterData> {
  static const SensorDataUnion enum_value = SensorDataUnion_MPLAltimeterData;
};

template<> struct SensorDataUnionTraits<SensorLog::BNO055Data> {
  static const SensorDataUnion enum_value = SensorDataUnion_BNO055Data;
};

bool VerifySensorDataUnion(::flatbuffers::Verifier &verifier, const void *obj, SensorDataUnion type);
bool VerifySensorDataUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct BME688Data FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BME688DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPERATURE = 4,
    VT_PRESSURE = 6,
    VT_HUMIDITY = 8,
    VT_GAS_RESISTANCE = 10,
    VT_ALTITUDE = 12
  };
  float temperature() const {
    return GetField<float>(VT_TEMPERATURE, 0.0f);
  }
  float pressure() const {
    return GetField<float>(VT_PRESSURE, 0.0f);
  }
  float humidity() const {
    return GetField<float>(VT_HUMIDITY, 0.0f);
  }
  float gas_resistance() const {
    return GetField<float>(VT_GAS_RESISTANCE, 0.0f);
  }
  float altitude() const {
    return GetField<float>(VT_ALTITUDE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TEMPERATURE, 4) &&
           VerifyField<float>(verifier, VT_PRESSURE, 4) &&
           VerifyField<float>(verifier, VT_HUMIDITY, 4) &&
           VerifyField<float>(verifier, VT_GAS_RESISTANCE, 4) &&
           VerifyField<float>(verifier, VT_ALTITUDE, 4) &&
           verifier.EndTable();
  }
};

struct BME688DataBuilder {
  typedef BME688Data Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_temperature(float temperature) {
    fbb_.AddElement<float>(BME688Data::VT_TEMPERATURE, temperature, 0.0f);
  }
  void add_pressure(float pressure) {
    fbb_.AddElement<float>(BME688Data::VT_PRESSURE, pressure, 0.0f);
  }
  void add_humidity(float humidity) {
    fbb_.AddElement<float>(BME688Data::VT_HUMIDITY, humidity, 0.0f);
  }
  void add_gas_resistance(float gas_resistance) {
    fbb_.AddElement<float>(BME688Data::VT_GAS_RESISTANCE, gas_resistance, 0.0f);
  }
  void add_altitude(float altitude) {
    fbb_.AddElement<float>(BME688Data::VT_ALTITUDE, altitude, 0.0f);
  }
  explicit BME688DataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BME688Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BME688Data>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BME688Data> CreateBME688Data(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float temperature = 0.0f,
    float pressure = 0.0f,
    float humidity = 0.0f,
    float gas_resistance = 0.0f,
    float altitude = 0.0f) {
  BME688DataBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_gas_resistance(gas_resistance);
  builder_.add_humidity(humidity);
  builder_.add_pressure(pressure);
  builder_.add_temperature(temperature);
  return builder_.Finish();
}

struct ENS160Data FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ENS160DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AQI = 4,
    VT_TVOC = 6,
    VT_ECO2 = 8,
    VT_HP0 = 10,
    VT_HP1 = 12,
    VT_HP2 = 14,
    VT_HP3 = 16
  };
  int32_t aqi() const {
    return GetField<int32_t>(VT_AQI, 0);
  }
  int32_t tvoc() const {
    return GetField<int32_t>(VT_TVOC, 0);
  }
  int32_t eco2() const {
    return GetField<int32_t>(VT_ECO2, 0);
  }
  float hp0() const {
    return GetField<float>(VT_HP0, 0.0f);
  }
  float hp1() const {
    return GetField<float>(VT_HP1, 0.0f);
  }
  float hp2() const {
    return GetField<float>(VT_HP2, 0.0f);
  }
  float hp3() const {
    return GetField<float>(VT_HP3, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AQI, 4) &&
           VerifyField<int32_t>(verifier, VT_TVOC, 4) &&
           VerifyField<int32_t>(verifier, VT_ECO2, 4) &&
           VerifyField<float>(verifier, VT_HP0, 4) &&
           VerifyField<float>(verifier, VT_HP1, 4) &&
           VerifyField<float>(verifier, VT_HP2, 4) &&
           VerifyField<float>(verifier, VT_HP3, 4) &&
           verifier.EndTable();
  }
};

struct ENS160DataBuilder {
  typedef ENS160Data Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_aqi(int32_t aqi) {
    fbb_.AddElement<int32_t>(ENS160Data::VT_AQI, aqi, 0);
  }
  void add_tvoc(int32_t tvoc) {
    fbb_.AddElement<int32_t>(ENS160Data::VT_TVOC, tvoc, 0);
  }
  void add_eco2(int32_t eco2) {
    fbb_.AddElement<int32_t>(ENS160Data::VT_ECO2, eco2, 0);
  }
  void add_hp0(float hp0) {
    fbb_.AddElement<float>(ENS160Data::VT_HP0, hp0, 0.0f);
  }
  void add_hp1(float hp1) {
    fbb_.AddElement<float>(ENS160Data::VT_HP1, hp1, 0.0f);
  }
  void add_hp2(float hp2) {
    fbb_.AddElement<float>(ENS160Data::VT_HP2, hp2, 0.0f);
  }
  void add_hp3(float hp3) {
    fbb_.AddElement<float>(ENS160Data::VT_HP3, hp3, 0.0f);
  }
  explicit ENS160DataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ENS160Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ENS160Data>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ENS160Data> CreateENS160Data(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t aqi = 0,
    int32_t tvoc = 0,
    int32_t eco2 = 0,
    float hp0 = 0.0f,
    float hp1 = 0.0f,
    float hp2 = 0.0f,
    float hp3 = 0.0f) {
  ENS160DataBuilder builder_(_fbb);
  builder_.add_hp3(hp3);
  builder_.add_hp2(hp2);
  builder_.add_hp1(hp1);
  builder_.add_hp0(hp0);
  builder_.add_eco2(eco2);
  builder_.add_tvoc(tvoc);
  builder_.add_aqi(aqi);
  return builder_.Finish();
}

struct LSM6D032Data FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LSM6D032DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCEL_X = 4,
    VT_ACCEL_Y = 6,
    VT_ACCEL_Z = 8,
    VT_GYRO_X = 10,
    VT_GYRO_Y = 12,
    VT_GYRO_Z = 14
  };
  float accel_x() const {
    return GetField<float>(VT_ACCEL_X, 0.0f);
  }
  float accel_y() const {
    return GetField<float>(VT_ACCEL_Y, 0.0f);
  }
  float accel_z() const {
    return GetField<float>(VT_ACCEL_Z, 0.0f);
  }
  float gyro_x() const {
    return GetField<float>(VT_GYRO_X, 0.0f);
  }
  float gyro_y() const {
    return GetField<float>(VT_GYRO_Y, 0.0f);
  }
  float gyro_z() const {
    return GetField<float>(VT_GYRO_Z, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ACCEL_X, 4) &&
           VerifyField<float>(verifier, VT_ACCEL_Y, 4) &&
           VerifyField<float>(verifier, VT_ACCEL_Z, 4) &&
           VerifyField<float>(verifier, VT_GYRO_X, 4) &&
           VerifyField<float>(verifier, VT_GYRO_Y, 4) &&
           VerifyField<float>(verifier, VT_GYRO_Z, 4) &&
           verifier.EndTable();
  }
};

struct LSM6D032DataBuilder {
  typedef LSM6D032Data Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_accel_x(float accel_x) {
    fbb_.AddElement<float>(LSM6D032Data::VT_ACCEL_X, accel_x, 0.0f);
  }
  void add_accel_y(float accel_y) {
    fbb_.AddElement<float>(LSM6D032Data::VT_ACCEL_Y, accel_y, 0.0f);
  }
  void add_accel_z(float accel_z) {
    fbb_.AddElement<float>(LSM6D032Data::VT_ACCEL_Z, accel_z, 0.0f);
  }
  void add_gyro_x(float gyro_x) {
    fbb_.AddElement<float>(LSM6D032Data::VT_GYRO_X, gyro_x, 0.0f);
  }
  void add_gyro_y(float gyro_y) {
    fbb_.AddElement<float>(LSM6D032Data::VT_GYRO_Y, gyro_y, 0.0f);
  }
  void add_gyro_z(float gyro_z) {
    fbb_.AddElement<float>(LSM6D032Data::VT_GYRO_Z, gyro_z, 0.0f);
  }
  explicit LSM6D032DataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LSM6D032Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LSM6D032Data>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LSM6D032Data> CreateLSM6D032Data(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float accel_x = 0.0f,
    float accel_y = 0.0f,
    float accel_z = 0.0f,
    float gyro_x = 0.0f,
    float gyro_y = 0.0f,
    float gyro_z = 0.0f) {
  LSM6D032DataBuilder builder_(_fbb);
  builder_.add_gyro_z(gyro_z);
  builder_.add_gyro_y(gyro_y);
  builder_.add_gyro_x(gyro_x);
  builder_.add_accel_z(accel_z);
  builder_.add_accel_y(accel_y);
  builder_.add_accel_x(accel_x);
  return builder_.Finish();
}

struct MPLAltimeterData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MPLAltimeterDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRESSURE = 4,
    VT_ALTITUDE = 6
  };
  float pressure() const {
    return GetField<float>(VT_PRESSURE, 0.0f);
  }
  float altitude() const {
    return GetField<float>(VT_ALTITUDE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_PRESSURE, 4) &&
           VerifyField<float>(verifier, VT_ALTITUDE, 4) &&
           verifier.EndTable();
  }
};

struct MPLAltimeterDataBuilder {
  typedef MPLAltimeterData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pressure(float pressure) {
    fbb_.AddElement<float>(MPLAltimeterData::VT_PRESSURE, pressure, 0.0f);
  }
  void add_altitude(float altitude) {
    fbb_.AddElement<float>(MPLAltimeterData::VT_ALTITUDE, altitude, 0.0f);
  }
  explicit MPLAltimeterDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MPLAltimeterData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MPLAltimeterData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MPLAltimeterData> CreateMPLAltimeterData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float pressure = 0.0f,
    float altitude = 0.0f) {
  MPLAltimeterDataBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_pressure(pressure);
  return builder_.Finish();
}

struct BNO055Data FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BNO055DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCEL_X = 4,
    VT_ACCEL_Y = 6,
    VT_ACCEL_Z = 8,
    VT_MAG_X = 10,
    VT_MAG_Y = 12,
    VT_MAG_Z = 14,
    VT_GYRO_X = 16,
    VT_GYRO_Y = 18,
    VT_GYRO_Z = 20,
    VT_EULER_HEADING = 22,
    VT_EULER_ROLL = 24,
    VT_EULER_PITCH = 26,
    VT_LINEAR_ACCEL_X = 28,
    VT_LINEAR_ACCEL_Y = 30,
    VT_LINEAR_ACCEL_Z = 32,
    VT_GRAVITY_X = 34,
    VT_GRAVITY_Y = 36,
    VT_GRAVITY_Z = 38,
    VT_CALIBRATION_STATUS_SYSTEM = 40,
    VT_CALIBRATION_STATUS_GYRO = 42,
    VT_CALIBRATION_STATUS_ACCEL = 44,
    VT_CALIBRATION_STATUS_MAG = 46
  };
  float accel_x() const {
    return GetField<float>(VT_ACCEL_X, 0.0f);
  }
  float accel_y() const {
    return GetField<float>(VT_ACCEL_Y, 0.0f);
  }
  float accel_z() const {
    return GetField<float>(VT_ACCEL_Z, 0.0f);
  }
  float mag_x() const {
    return GetField<float>(VT_MAG_X, 0.0f);
  }
  float mag_y() const {
    return GetField<float>(VT_MAG_Y, 0.0f);
  }
  float mag_z() const {
    return GetField<float>(VT_MAG_Z, 0.0f);
  }
  float gyro_x() const {
    return GetField<float>(VT_GYRO_X, 0.0f);
  }
  float gyro_y() const {
    return GetField<float>(VT_GYRO_Y, 0.0f);
  }
  float gyro_z() const {
    return GetField<float>(VT_GYRO_Z, 0.0f);
  }
  float euler_heading() const {
    return GetField<float>(VT_EULER_HEADING, 0.0f);
  }
  float euler_roll() const {
    return GetField<float>(VT_EULER_ROLL, 0.0f);
  }
  float euler_pitch() const {
    return GetField<float>(VT_EULER_PITCH, 0.0f);
  }
  float linear_accel_x() const {
    return GetField<float>(VT_LINEAR_ACCEL_X, 0.0f);
  }
  float linear_accel_y() const {
    return GetField<float>(VT_LINEAR_ACCEL_Y, 0.0f);
  }
  float linear_accel_z() const {
    return GetField<float>(VT_LINEAR_ACCEL_Z, 0.0f);
  }
  float gravity_x() const {
    return GetField<float>(VT_GRAVITY_X, 0.0f);
  }
  float gravity_y() const {
    return GetField<float>(VT_GRAVITY_Y, 0.0f);
  }
  float gravity_z() const {
    return GetField<float>(VT_GRAVITY_Z, 0.0f);
  }
  int8_t calibration_status_system() const {
    return GetField<int8_t>(VT_CALIBRATION_STATUS_SYSTEM, 0);
  }
  int8_t calibration_status_gyro() const {
    return GetField<int8_t>(VT_CALIBRATION_STATUS_GYRO, 0);
  }
  int8_t calibration_status_accel() const {
    return GetField<int8_t>(VT_CALIBRATION_STATUS_ACCEL, 0);
  }
  int8_t calibration_status_mag() const {
    return GetField<int8_t>(VT_CALIBRATION_STATUS_MAG, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ACCEL_X, 4) &&
           VerifyField<float>(verifier, VT_ACCEL_Y, 4) &&
           VerifyField<float>(verifier, VT_ACCEL_Z, 4) &&
           VerifyField<float>(verifier, VT_MAG_X, 4) &&
           VerifyField<float>(verifier, VT_MAG_Y, 4) &&
           VerifyField<float>(verifier, VT_MAG_Z, 4) &&
           VerifyField<float>(verifier, VT_GYRO_X, 4) &&
           VerifyField<float>(verifier, VT_GYRO_Y, 4) &&
           VerifyField<float>(verifier, VT_GYRO_Z, 4) &&
           VerifyField<float>(verifier, VT_EULER_HEADING, 4) &&
           VerifyField<float>(verifier, VT_EULER_ROLL, 4) &&
           VerifyField<float>(verifier, VT_EULER_PITCH, 4) &&
           VerifyField<float>(verifier, VT_LINEAR_ACCEL_X, 4) &&
           VerifyField<float>(verifier, VT_LINEAR_ACCEL_Y, 4) &&
           VerifyField<float>(verifier, VT_LINEAR_ACCEL_Z, 4) &&
           VerifyField<float>(verifier, VT_GRAVITY_X, 4) &&
           VerifyField<float>(verifier, VT_GRAVITY_Y, 4) &&
           VerifyField<float>(verifier, VT_GRAVITY_Z, 4) &&
           VerifyField<int8_t>(verifier, VT_CALIBRATION_STATUS_SYSTEM, 1) &&
           VerifyField<int8_t>(verifier, VT_CALIBRATION_STATUS_GYRO, 1) &&
           VerifyField<int8_t>(verifier, VT_CALIBRATION_STATUS_ACCEL, 1) &&
           VerifyField<int8_t>(verifier, VT_CALIBRATION_STATUS_MAG, 1) &&
           verifier.EndTable();
  }
};

struct BNO055DataBuilder {
  typedef BNO055Data Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_accel_x(float accel_x) {
    fbb_.AddElement<float>(BNO055Data::VT_ACCEL_X, accel_x, 0.0f);
  }
  void add_accel_y(float accel_y) {
    fbb_.AddElement<float>(BNO055Data::VT_ACCEL_Y, accel_y, 0.0f);
  }
  void add_accel_z(float accel_z) {
    fbb_.AddElement<float>(BNO055Data::VT_ACCEL_Z, accel_z, 0.0f);
  }
  void add_mag_x(float mag_x) {
    fbb_.AddElement<float>(BNO055Data::VT_MAG_X, mag_x, 0.0f);
  }
  void add_mag_y(float mag_y) {
    fbb_.AddElement<float>(BNO055Data::VT_MAG_Y, mag_y, 0.0f);
  }
  void add_mag_z(float mag_z) {
    fbb_.AddElement<float>(BNO055Data::VT_MAG_Z, mag_z, 0.0f);
  }
  void add_gyro_x(float gyro_x) {
    fbb_.AddElement<float>(BNO055Data::VT_GYRO_X, gyro_x, 0.0f);
  }
  void add_gyro_y(float gyro_y) {
    fbb_.AddElement<float>(BNO055Data::VT_GYRO_Y, gyro_y, 0.0f);
  }
  void add_gyro_z(float gyro_z) {
    fbb_.AddElement<float>(BNO055Data::VT_GYRO_Z, gyro_z, 0.0f);
  }
  void add_euler_heading(float euler_heading) {
    fbb_.AddElement<float>(BNO055Data::VT_EULER_HEADING, euler_heading, 0.0f);
  }
  void add_euler_roll(float euler_roll) {
    fbb_.AddElement<float>(BNO055Data::VT_EULER_ROLL, euler_roll, 0.0f);
  }
  void add_euler_pitch(float euler_pitch) {
    fbb_.AddElement<float>(BNO055Data::VT_EULER_PITCH, euler_pitch, 0.0f);
  }
  void add_linear_accel_x(float linear_accel_x) {
    fbb_.AddElement<float>(BNO055Data::VT_LINEAR_ACCEL_X, linear_accel_x, 0.0f);
  }
  void add_linear_accel_y(float linear_accel_y) {
    fbb_.AddElement<float>(BNO055Data::VT_LINEAR_ACCEL_Y, linear_accel_y, 0.0f);
  }
  void add_linear_accel_z(float linear_accel_z) {
    fbb_.AddElement<float>(BNO055Data::VT_LINEAR_ACCEL_Z, linear_accel_z, 0.0f);
  }
  void add_gravity_x(float gravity_x) {
    fbb_.AddElement<float>(BNO055Data::VT_GRAVITY_X, gravity_x, 0.0f);
  }
  void add_gravity_y(float gravity_y) {
    fbb_.AddElement<float>(BNO055Data::VT_GRAVITY_Y, gravity_y, 0.0f);
  }
  void add_gravity_z(float gravity_z) {
    fbb_.AddElement<float>(BNO055Data::VT_GRAVITY_Z, gravity_z, 0.0f);
  }
  void add_calibration_status_system(int8_t calibration_status_system) {
    fbb_.AddElement<int8_t>(BNO055Data::VT_CALIBRATION_STATUS_SYSTEM, calibration_status_system, 0);
  }
  void add_calibration_status_gyro(int8_t calibration_status_gyro) {
    fbb_.AddElement<int8_t>(BNO055Data::VT_CALIBRATION_STATUS_GYRO, calibration_status_gyro, 0);
  }
  void add_calibration_status_accel(int8_t calibration_status_accel) {
    fbb_.AddElement<int8_t>(BNO055Data::VT_CALIBRATION_STATUS_ACCEL, calibration_status_accel, 0);
  }
  void add_calibration_status_mag(int8_t calibration_status_mag) {
    fbb_.AddElement<int8_t>(BNO055Data::VT_CALIBRATION_STATUS_MAG, calibration_status_mag, 0);
  }
  explicit BNO055DataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BNO055Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BNO055Data>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BNO055Data> CreateBNO055Data(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float accel_x = 0.0f,
    float accel_y = 0.0f,
    float accel_z = 0.0f,
    float mag_x = 0.0f,
    float mag_y = 0.0f,
    float mag_z = 0.0f,
    float gyro_x = 0.0f,
    float gyro_y = 0.0f,
    float gyro_z = 0.0f,
    float euler_heading = 0.0f,
    float euler_roll = 0.0f,
    float euler_pitch = 0.0f,
    float linear_accel_x = 0.0f,
    float linear_accel_y = 0.0f,
    float linear_accel_z = 0.0f,
    float gravity_x = 0.0f,
    float gravity_y = 0.0f,
    float gravity_z = 0.0f,
    int8_t calibration_status_system = 0,
    int8_t calibration_status_gyro = 0,
    int8_t calibration_status_accel = 0,
    int8_t calibration_status_mag = 0) {
  BNO055DataBuilder builder_(_fbb);
  builder_.add_gravity_z(gravity_z);
  builder_.add_gravity_y(gravity_y);
  builder_.add_gravity_x(gravity_x);
  builder_.add_linear_accel_z(linear_accel_z);
  builder_.add_linear_accel_y(linear_accel_y);
  builder_.add_linear_accel_x(linear_accel_x);
  builder_.add_euler_pitch(euler_pitch);
  builder_.add_euler_roll(euler_roll);
  builder_.add_euler_heading(euler_heading);
  builder_.add_gyro_z(gyro_z);
  builder_.add_gyro_y(gyro_y);
  builder_.add_gyro_x(gyro_x);
  builder_.add_mag_z(mag_z);
  builder_.add_mag_y(mag_y);
  builder_.add_mag_x(mag_x);
  builder_.add_accel_z(accel_z);
  builder_.add_accel_y(accel_y);
  builder_.add_accel_x(accel_x);
  builder_.add_calibration_status_mag(calibration_status_mag);
  builder_.add_calibration_status_accel(calibration_status_accel);
  builder_.add_calibration_status_gyro(calibration_status_gyro);
  builder_.add_calibration_status_system(calibration_status_system);
  return builder_.Finish();
}

struct SensorMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SensorMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENSOR_TYPE = 4,
    VT_TIMESTAMP = 6,
    VT_DATA_TYPE = 8,
    VT_DATA = 10
  };
  SensorLog::SensorType sensor_type() const {
    return static_cast<SensorLog::SensorType>(GetField<int8_t>(VT_SENSOR_TYPE, 0));
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  SensorLog::SensorDataUnion data_type() const {
    return static_cast<SensorLog::SensorDataUnion>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const SensorLog::BME688Data *data_as_BME688Data() const {
    return data_type() == SensorLog::SensorDataUnion_BME688Data ? static_cast<const SensorLog::BME688Data *>(data()) : nullptr;
  }
  const SensorLog::ENS160Data *data_as_ENS160Data() const {
    return data_type() == SensorLog::SensorDataUnion_ENS160Data ? static_cast<const SensorLog::ENS160Data *>(data()) : nullptr;
  }
  const SensorLog::LSM6D032Data *data_as_LSM6D032Data() const {
    return data_type() == SensorLog::SensorDataUnion_LSM6D032Data ? static_cast<const SensorLog::LSM6D032Data *>(data()) : nullptr;
  }
  const SensorLog::MPLAltimeterData *data_as_MPLAltimeterData() const {
    return data_type() == SensorLog::SensorDataUnion_MPLAltimeterData ? static_cast<const SensorLog::MPLAltimeterData *>(data()) : nullptr;
  }
  const SensorLog::BNO055Data *data_as_BNO055Data() const {
    return data_type() == SensorLog::SensorDataUnion_BNO055Data ? static_cast<const SensorLog::BNO055Data *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SENSOR_TYPE, 1) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifySensorDataUnion(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const SensorLog::BME688Data *SensorMessage::data_as<SensorLog::BME688Data>() const {
  return data_as_BME688Data();
}

template<> inline const SensorLog::ENS160Data *SensorMessage::data_as<SensorLog::ENS160Data>() const {
  return data_as_ENS160Data();
}

template<> inline const SensorLog::LSM6D032Data *SensorMessage::data_as<SensorLog::LSM6D032Data>() const {
  return data_as_LSM6D032Data();
}

template<> inline const SensorLog::MPLAltimeterData *SensorMessage::data_as<SensorLog::MPLAltimeterData>() const {
  return data_as_MPLAltimeterData();
}

template<> inline const SensorLog::BNO055Data *SensorMessage::data_as<SensorLog::BNO055Data>() const {
  return data_as_BNO055Data();
}

struct SensorMessageBuilder {
  typedef SensorMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sensor_type(SensorLog::SensorType sensor_type) {
    fbb_.AddElement<int8_t>(SensorMessage::VT_SENSOR_TYPE, static_cast<int8_t>(sensor_type), 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(SensorMessage::VT_TIMESTAMP, timestamp, 0);
  }
  void add_data_type(SensorLog::SensorDataUnion data_type) {
    fbb_.AddElement<uint8_t>(SensorMessage::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(SensorMessage::VT_DATA, data);
  }
  explicit SensorMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SensorMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SensorMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SensorMessage> CreateSensorMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    SensorLog::SensorType sensor_type = SensorLog::SensorType_BME688,
    uint64_t timestamp = 0,
    SensorLog::SensorDataUnion data_type = SensorLog::SensorDataUnion_NONE,
    ::flatbuffers::Offset<void> data = 0) {
  SensorMessageBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_sensor_type(sensor_type);
  return builder_.Finish();
}

struct SensorBatch FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SensorBatchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_MESSAGES = 6
  };
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<SensorLog::SensorMessage>> *messages() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SensorLog::SensorMessage>> *>(VT_MESSAGES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           verifier.EndTable();
  }
};

struct SensorBatchBuilder {
  typedef SensorBatch Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(SensorBatch::VT_TIMESTAMP, timestamp, 0);
  }
  void add_messages(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SensorLog::SensorMessage>>> messages) {
    fbb_.AddOffset(SensorBatch::VT_MESSAGES, messages);
  }
  explicit SensorBatchBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SensorBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SensorBatch>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SensorBatch> CreateSensorBatch(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SensorLog::SensorMessage>>> messages = 0) {
  SensorBatchBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_messages(messages);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SensorBatch> CreateSensorBatchDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    const std::vector<::flatbuffers::Offset<SensorLog::SensorMessage>> *messages = nullptr) {
  auto messages__ = messages ? _fbb.CreateVector<::flatbuffers::Offset<SensorLog::SensorMessage>>(*messages) : 0;
  return SensorLog::CreateSensorBatch(
      _fbb,
      timestamp,
      messages__);
}

inline bool VerifySensorDataUnion(::flatbuffers::Verifier &verifier, const void *obj, SensorDataUnion type) {
  switch (type) {
    case SensorDataUnion_NONE: {
      return true;
    }
    case SensorDataUnion_BME688Data: {
      auto ptr = reinterpret_cast<const SensorLog::BME688Data *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SensorDataUnion_ENS160Data: {
      auto ptr = reinterpret_cast<const SensorLog::ENS160Data *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SensorDataUnion_LSM6D032Data: {
      auto ptr = reinterpret_cast<const SensorLog::LSM6D032Data *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SensorDataUnion_MPLAltimeterData: {
      auto ptr = reinterpret_cast<const SensorLog::MPLAltimeterData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SensorDataUnion_BNO055Data: {
      auto ptr = reinterpret_cast<const SensorLog::BNO055Data *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySensorDataUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySensorDataUnion(
        verifier,  values->Get(i), types->GetEnum<SensorDataUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const SensorLog::SensorBatch *GetSensorBatch(const void *buf) {
  return ::flatbuffers::GetRoot<SensorLog::SensorBatch>(buf);
}

inline const SensorLog::SensorBatch *GetSizePrefixedSensorBatch(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SensorLog::SensorBatch>(buf);
}

inline bool VerifySensorBatchBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SensorLog::SensorBatch>(nullptr);
}

inline bool VerifySizePrefixedSensorBatchBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SensorLog::SensorBatch>(nullptr);
}

inline void FinishSensorBatchBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SensorLog::SensorBatch> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSensorBatchBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SensorLog::SensorBatch> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace SensorLog

#endif  // FLATBUFFERS_GENERATED_SENSORS_SENSORLOG_H_
